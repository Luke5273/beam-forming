clear; close all;
rng('shuffle');
c = 343; %sound
trials = 10;
Fs = 10e3;

thermal_noise_sigma = 50e-6;
timing_window = 20e-6;

mic_noise = 0.00;
adc_noise = 0.15;

mic_pos = [
    0 0;
    1 1;
    1 -1;
    -1 1;
    -1 -1
];
num_mics = size(mic_pos, 1);
power_const = 1/sqrt(num_mics);

target_pos = [5 2];

fc = 100;
t = 0:1/Fs:10/fc;
x = sin(2*pi*fc*t);

distances = sqrt((mic_pos(:, 1)-target_pos(1)).^2 + (mic_pos(:, 2)-target_pos(2)).^2);
tau = distances/c;
tau_max = max(tau);
weights = 1./distances;
weights = weights / norm(weights) * sqrt(num_mics);

y = zeros(size(x));
y_nobf = zeros(size(x));
y_weighted_bf = zeros(size(x));
y_clean = zeros(size(x));
y_clean_nobf = zeros(size(x));
y_clean_weighted_bf = zeros(size(x));
n = 0:length(x)-1;

for i = 1:num_mics
    delay_needed = (tau_max - tau(i) + timing_window*rand) * Fs;
    aligned = interp1(n, x, n - delay_needed, 'spline', 0);
    
    delayed = channelDelay(aligned, Fs, tau(i));
    
    clean_sig = power_const*delayed/distances(i);
    clean_sig_weighted = weights(i)*delayed/distances(i);

    y = y + clean_sig + mic_noise*randn(size(y));
    y_clean = y_clean + clean_sig;
    y_weighted_bf = y + clean_sig_weighted + mic_noise*randn(size(y));
    y_clean_weighted_bf = y_clean_weighted_bf + mic_noise*clean_sig_weighted;
    
    if(i==1)
        y_nobf = delayed/distances(i) + mic_noise*randn(size(y));
        y_clean_nobf = delayed/distances(i);
    end
end
adc = adc_noise*randn(size(y));

y = y + adc;
y_nobf = y_nobf + adc;
y_weighted_bf = y_weighted_bf + adc;

noise_bf = y - y_clean;
noise_nobf = y_nobf - y_clean_nobf;
noise_weighted_bf = y_w - y_clean;

snr_bf = 10*log10(var(y_clean)/var(noise_bf));
snr_nobf = 10*log10(var(y_clean_nobf)/var(noise_nobf));

gain = snr_bf - snr_nobf;

fprintf('Beamformed SNR: %.2f dB\n', snr_bf);
fprintf('No Beamforming SNR: %.2f dB\n', snr_nobf);
fprintf('Beamforming Gain: %.2f dB\n', gain);

subplot(2,1,1);
plot(t, y);
ylim([-1 1]);
subplot(2,1,2);
plot(t, y_nobf);
ylim([-1 1]);
